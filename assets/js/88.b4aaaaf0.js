(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{409:function(t,a,s){"use strict";s.r(a);var e=s(3),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[a("strong",[t._v("CAS:")]),t._v(" 比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。")])]),t._v(" "),a("h2",{attrs:{id:"悲观锁和乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁和乐观锁"}},[t._v("#")]),t._v(" 悲观锁和乐观锁")]),t._v(" "),a("h3",{attrs:{id:"_1-悲观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-悲观锁"}},[t._v("#")]),t._v(" 1. 悲观锁")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以"),a("strong",[t._v("每次在拿数据的时候都会上锁")]),t._v("，这样别人想拿这个数据就会block直到它拿到锁。")])]),t._v(" "),a("li",[a("p",[t._v("悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。")])])]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220621111315.png",alt:"image-20211115110618926"}}),t._v(" "),a("blockquote",[a("h4",{attrs:{id:"悲观锁实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁实现方式"}},[t._v("#")]),t._v(" 悲观锁实现方式:")]),t._v(" "),a("p",[t._v("a 在获取资源准备操作时在第三个库插入一条数据,")]),t._v(" "),a("p",[t._v("b 在获取资源之前去第三个库查询是否存在, 存在不操作, 不存在就获取资源, 然后在第三个库插入一条数据.")])]),t._v(" "),a("h3",{attrs:{id:"_2-乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-乐观锁"}},[t._v("#")]),t._v(" 2. 乐观锁")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是**在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。**乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。")])]),t._v(" "),a("li",[a("p",[t._v("乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。")])])]),t._v(" "),a("blockquote",[a("h4",{attrs:{id:"乐观锁实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁实现方式"}},[t._v("#")]),t._v(" 乐观锁实现方式:")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。")])]),t._v(" "),a("li",[a("p",[t._v("使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。")])])])]),t._v(" "),a("h2",{attrs:{id:"cas运行方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cas运行方式"}},[t._v("#")]),t._v(" CAS运行方式")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。")])]),t._v(" "),a("li",[a("p",[t._v("有两个goroutineA和goroutineB，接下来我们简称 A 和 B， 共享资源称为C")]),t._v(" "),a("ol",[a("li",[t._v("A 和 B 均保存 C 当前的值")]),t._v(" "),a("li",[t._v("A 尝试使用CAS（56，53）更新C的值")]),t._v(" "),a("li",[t._v("C目前为56，可以更新，然后更新成功")]),t._v(" "),a("li",[t._v("B尝试使用CAS（56，53）更新C的值")]),t._v(" "),a("li",[t._v("C已经为53，更新失败")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220621112318.png",alt:"image-20220621112318915"}})])])]),t._v(" "),a("h2",{attrs:{id:"cas源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cas源码"}},[t._v("#")]),t._v(" CAS源码")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("code")]),t._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("CompareAndSwapUint32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("addr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" old"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("swapped "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])])]),t._v(" "),a("li",[a("p",[t._v("实际代码文件在 Go / src / runtime / internal / atomic / asm_amd.s文件中")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("TEXT runtime∕internal∕atomic·Cas64(SB), NOSPLIT, $0-25\n MOVQ ptr+0(FP), BX\n MOVQ old+8(FP), AX\n MOVQ new+16(FP), CX\n LOCK\n CMPXCHGQ CX, 0(BX)\n SETEQ ret+24(FP)\n RET\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("ul",[a("li",[a("p",[t._v("lock(一个命令前缀，在这里用于CMPXCHGQ)可以锁住总线保证多次内存操作的原子性。\n然后执行CMPXCHGQ")]),t._v(" "),a("blockquote",[a("p",[t._v("cmpxchg %cx, %bx；如果AX与BX相等，则CX送BX且ZF置1；否则BX送CX，且ZF清0")])]),t._v(" "),a("ol",[a("li",[t._v("拿AX(old) 与 BX(共享数据ptr) 做对比。")]),t._v(" "),a("li",[t._v("相等，则修改BX(共享数据ptr)，状态码ZX设置为 1 。")]),t._v(" "),a("li",[t._v("不相等，则将CX(new)置为目前BX(共享数据ptr)的值， 状态码ZX设置为 0")])])])])])]),t._v(" "),a("h2",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),a("h3",{attrs:{id:"_1-如何保证原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何保证原子性"}},[t._v("#")]),t._v(" 1. 如何保证原子性")]),t._v(" "),a("ul",[a("li",[t._v("既然CAS包含了Compare和Swap两个操作，它又如何保证原子性呢？")]),t._v(" "),a("li",[t._v("答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。")])]),t._v(" "),a("h3",{attrs:{id:"_2-cas的缺陷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-cas的缺陷"}},[t._v("#")]),t._v(" 2. CAS的缺陷")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("CAS在共享资源竞争比较激烈的时候，每个goroutine会容易处于自旋状态，影响效率，在竞争激烈的时候推荐使用锁。")])]),t._v(" "),a("li",[a("p",[t._v("无法解决ABA问题")]),t._v(" "),a("ul",[a("li",[t._v("ABA问题是无锁结构实现中常见的一种问题，可基本表述为：")])]),t._v(" "),a("blockquote",[a("p",[t._v("进程P1读取了一个数值A\nP1被挂起(时间片耗尽、中断等)，进程P2开始执行\nP2修改数值A为数值B，然后又修改回A\nP1被唤醒，比较后发现数值A没有变化，程序继续执行。")])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);