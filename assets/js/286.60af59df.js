(window.webpackJsonp=window.webpackJsonp||[]).push([[286],{607:function(v,_,t){"use strict";t.r(_);var l=t(3),s=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),_("ul",[_("li",[v._v("把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)。")]),v._v(" "),_("li",[v._v("分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。")]),v._v(" "),_("li",[v._v("分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。")]),v._v(" "),_("li",[v._v("实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。\n"),_("ol",[_("li",[v._v("一定是先找到最小问题规模时的求解方法")]),v._v(" "),_("li",[v._v("然后考虑随着问题规模增大时的求解方法")]),v._v(" "),_("li",[v._v("找到求解的递归函数式后（各种规模或因子），设计递归程序即可。")])])])]),v._v(" "),_("h2",{attrs:{id:"应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[v._v("#")]),v._v(" 应用场景")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("分治法所能解决的问题一般具有以下几个特征：")]),v._v(" "),_("ol",[_("li",[v._v("该问题的规模缩小到一定的程度就可以容易地解决")]),v._v(" "),_("li",[v._v("该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。")]),v._v(" "),_("li",[v._v("利用该问题分解出的子问题的解可以合并为该问题的解；")]),v._v(" "),_("li",[v._v("该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。")])])]),v._v(" "),_("li",[_("p",[v._v("第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("第二条特征是应用分治法的前提")]),v._v("它也是大多数问题可以满足的，此特征反映了递归思想的应用；、")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征")]),v._v("，如果"),_("strong",[v._v("具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("第四条特征涉及到分治法的效率")]),v._v("，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但"),_("strong",[v._v("一般用动态规划法较好")]),v._v("。")])])]),v._v(" "),_("h2",{attrs:{id:"分治的基本步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治的基本步骤"}},[v._v("#")]),v._v(" 分治的基本步骤")]),v._v(" "),_("ul",[_("li",[v._v("分治法在每一层递归上都有三个步骤：\n"),_("ul",[_("li",[v._v("step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；")]),v._v(" "),_("li",[v._v("step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题")]),v._v(" "),_("li",[v._v("step3 合并：将各个子问题的解合并为原问题的解。")])])])]),v._v(" "),_("h2",{attrs:{id:"可使用分治法求解的一些经典问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可使用分治法求解的一些经典问题"}},[v._v("#")]),v._v(" 可使用分治法求解的一些经典问题")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("二分搜索")])]),v._v(" "),_("li",[_("p",[v._v("大整数乘法")])]),v._v(" "),_("li",[_("p",[v._v("Strassen矩阵乘法")])]),v._v(" "),_("li",[_("p",[v._v("棋盘覆盖")])]),v._v(" "),_("li",[_("p",[v._v("合并排序")])]),v._v(" "),_("li",[_("p",[v._v("快速排序")])]),v._v(" "),_("li",[_("p",[v._v("线性时间选择")])]),v._v(" "),_("li",[_("p",[v._v("最接近点对问题")])]),v._v(" "),_("li",[_("p",[v._v("循环赛日程表")])])]),v._v(" "),_("h2",{attrs:{id:"示例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[v._v("#")]),v._v(" 示例")])])}),[],!1,null,null,null);_.default=s.exports}}]);