(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{387:function(_,v,e){"use strict";e.r(v);var t=e(3),a=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("blockquote",[v("p",[_._v("主要介绍常见的Server的并发模型，这些模型与编程语言本身无关，有的编程语言可能在语法上直接透明了模型本质，所以开发者没必要一定要基于模型去编写，只是需要知道和了解并发模型的构成和特点即可。")])]),_._v(" "),v("h2",{attrs:{id:"模型一、单线程accept-无io复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型一、单线程accept-无io复用"}},[_._v("#")]),_._v(" 模型一、单线程Accept（无IO复用）")]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://img.kancloud.cn/3c/14/3c1458b97e48e71ea216e996aa3f2dc0_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("① 主线程"),v("code",[_._v("main thread")]),_._v("执行阻塞Accept，每次客户端Connect链接过来，"),v("code",[_._v("main thread")]),_._v("中accept响应并建立连接")]),_._v(" "),v("p",[_._v("② 创建链接成功，得到"),v("code",[_._v("Connfd1")]),_._v("套接字后, 依然在"),v("code",[_._v("main thread")]),_._v("串行处理套接字读写，并处理业务。")]),_._v(" "),v("p",[_._v("③ 在②处理业务中，如果有新客户端"),v("code",[_._v("Connect")]),_._v("过来，"),v("code",[_._v("Server")]),_._v("无响应，直到当前套接字全部业务处理完毕。")]),_._v(" "),v("p",[_._v("④ 当前客户端处理完后，完毕链接，处理下一个客户端请求。")]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("socket编程流程清晰且简单，适合学习使用，了解socket基本编程流程。")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("该模型并非并发模型，是串行的服务器，同一时刻，监听并响应最大的网络请求量为"),v("code",[_._v("1")]),_._v("。 即并发量为"),v("code",[_._v("1")]),_._v("。")]),_._v(" "),v("li",[_._v("仅适合学习基本socket编程，不适合任何服务器Server构建。")])]),_._v(" "),v("h2",{attrs:{id:"模型二、单线程accept-多线程读写业务-无io复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型二、单线程accept-多线程读写业务-无io复用"}},[_._v("#")]),_._v(" 模型二、单线程Accept+多线程读写业务（无IO复用）")]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图-2"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://img.kancloud.cn/75/eb/75ebef29690b072e206535c28e950301_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析-2"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("① 主线程"),v("code",[_._v("main thread")]),_._v("执行阻塞Accept，每次客户端Connect链接过来，"),v("code",[_._v("main thread")]),_._v("中accept响应并建立连接")]),_._v(" "),v("p",[_._v("② 创建链接成功，得到"),v("code",[_._v("Connfd1")]),_._v("套接字后，创建一个新线程"),v("code",[_._v("thread1")]),_._v("用来处理客户端的读写业务。"),v("code",[_._v("main thead")]),_._v("依然回到"),v("code",[_._v("Accept")]),_._v("阻塞等待新客户端。")]),_._v(" "),v("p",[_._v("③ "),v("code",[_._v("thread1")]),_._v("通过套接字"),v("code",[_._v("Connfd1")]),_._v("与客户端进行通信读写。")]),_._v(" "),v("p",[_._v("④ server在②处理业务中，如果有新客户端"),v("code",[_._v("Connect")]),_._v("过来，"),v("code",[_._v("main thread")]),_._v("中"),v("code",[_._v("Accept")]),_._v("依然响应并建立连接，重复②过程。")]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点-2"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("基于"),v("code",[_._v("模型一：单线程Accept（无IO复用）")]),_._v(" 支持了并发的特性。")]),_._v(" "),v("li",[_._v("使用灵活，一个客户端对应一个线程单独处理，"),v("code",[_._v("server")]),_._v("处理业务内聚程度高，客户端无论如何写，服务端均会有一个线程做资源响应。")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("随着客户端的数量增多，需要开辟的线程也增加，客户端与server线程数量"),v("code",[_._v("1:1")]),_._v("正比关系，一次对于高并发场景，线程数量收到硬件上限瓶颈。")])]),_._v(" "),v("li",[v("p",[_._v("对于长链接，客户端一旦无业务读写，只要不关闭，server的对应线程依然需要保持连接(心跳、健康监测等机制)，占用连接资源和线程开销资源浪费。")])]),_._v(" "),v("li",[v("p",[_._v("仅适合客户端数量不大，并且数量可控的场景使用。")])]),_._v(" "),v("li",[v("p",[_._v("仅适合学习基本socket编程，不适合任何服务器Server构建。")])])]),_._v(" "),v("h2",{attrs:{id:"模型三、单线程多路io复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型三、单线程多路io复用"}},[_._v("#")]),_._v(" 模型三、单线程多路IO复用")]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图-3"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/b78b7c25b26b1bf40a84ee7ea5bae313_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析-3"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("① 主线程"),v("code",[_._v("main thread")]),_._v("创建"),v("code",[_._v("listenFd")]),_._v("之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有"),v("code",[_._v("Client1")]),_._v("客户端"),v("code",[_._v("Connect")]),_._v("请求，I/O复用机制检测到"),v("code",[_._v("ListenFd")]),_._v("触发读事件，则进行"),v("code",[_._v("Accept")]),_._v("建立连接，并将新生成的"),v("code",[_._v("connFd1")]),_._v("加入到"),v("code",[_._v("监听I/O集合")]),_._v("中。")]),_._v(" "),v("p",[_._v("② "),v("code",[_._v("Client1")]),_._v("再次进行正常读写业务请求，"),v("code",[_._v("main thread")]),_._v("的"),v("code",[_._v("多路I/O复用机制")]),_._v("阻塞返回，会触该套接字的读/写事件等。")]),_._v(" "),v("p",[_._v("③ 对于"),v("code",[_._v("Client1")]),_._v("的读写业务，Server依然在"),v("code",[_._v("main thread")]),_._v("执行流程提继续执行，此时如果有新的客户端"),v("code",[_._v("Connect")]),_._v("链接请求过来，Server将没有即时响应。")]),_._v(" "),v("p",[_._v("④ 等到Server处理完一个连接的"),v("code",[_._v("Read+Write")]),_._v("操作，继续回到"),v("code",[_._v("多路I/O复用机制")]),_._v("阻塞，其他链接过来重复 ②、③流程。")]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点-3"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("单流程解决了可以同时监听多个客户端读写状态的模型，不需要"),v("code",[_._v("1:1")]),_._v("与客户端的线程数量关系。")]),_._v(" "),v("li",[_._v("多路I/O复用阻塞，非忙询状态，不浪费CPU资源， CPU利用率较高。")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("虽然可以监听多个客户端的读写状态，但是同一时间内，只能处理一个客户端的读写操作，实际上读写的业务并发为1。")]),_._v(" "),v("li",[_._v("多客户端访问Server，业务为串行执行，大量请求会有排队延迟现象，如图中⑤所示，当"),v("code",[_._v("Client3")]),_._v("占据"),v("code",[_._v("main thread")]),_._v("流程时，"),v("code",[_._v("Client1,Client2")]),_._v("流程卡在"),v("code",[_._v("IO复用")]),_._v("等待下次监听触发事件。")])]),_._v(" "),v("h2",{attrs:{id:"模型四、单线程多路io复用-多线程读写业务-业务工作池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型四、单线程多路io复用-多线程读写业务-业务工作池"}},[_._v("#")]),_._v(" 模型四、单线程多路IO复用+多线程读写业务(业务工作池)")]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图-4"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/148fb61338b6de7dd669acd4d611369d_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析-4"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("① 主线程"),v("code",[_._v("main thread")]),_._v("创建"),v("code",[_._v("listenFd")]),_._v("之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有"),v("code",[_._v("Client1")]),_._v("客户端"),v("code",[_._v("Connect")]),_._v("请求，I/O复用机制检测到"),v("code",[_._v("ListenFd")]),_._v("触发读事件，则进行"),v("code",[_._v("Accept")]),_._v("建立连接，并将新生成的"),v("code",[_._v("connFd1")]),_._v("加入到"),v("code",[_._v("监听I/O集合")]),_._v("中。")]),_._v(" "),v("p",[_._v("② 当"),v("code",[_._v("connFd1")]),_._v("有可读消息，触发读事件，并且进行读写消息")]),_._v(" "),v("p",[_._v("③ "),v("code",[_._v("main thread")]),_._v("按照固定的协议读取消息，并且交给"),v("code",[_._v("worker pool")]),_._v("工作线程池， 工作线程池在server启动之前就已经开启固定数量的"),v("code",[_._v("thread")]),_._v("，里面的线程只处理消息业务，不进行套接字读写操作。")]),_._v(" "),v("p",[_._v("④ 工作池处理完业务，触发"),v("code",[_._v("connFd1")]),_._v("写事件，将回执客户端的消息通过"),v("code",[_._v("main thead")]),_._v("写给对方。")]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点-4"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("对于"),v("code",[_._v("模型三")]),_._v(", 将业务处理部分，通过工作池分离出来，减少多客户端访问Server，业务为串行执行，大量请求会有排队延迟时间。")]),_._v(" "),v("li",[_._v("实际上读写的业务并发为1，但是业务流程并发为worker pool线程数量，加快了业务处理并行效率。")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("读写依然为"),v("code",[_._v("main thread")]),_._v("单独处理，最高读写并行通道依然为1.")]),_._v(" "),v("li",[_._v("虽然多个worker线程处理业务，但是最后返回给客户端，依旧需要排队，因为出口还是"),v("code",[_._v("main thread")]),_._v("的"),v("code",[_._v("Read + Write")])])]),_._v(" "),v("h2",{attrs:{id:"模型五、单线程io复用-多线程io复用-链接线程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型五、单线程io复用-多线程io复用-链接线程池"}},[_._v("#")]),_._v(" 模型五、单线程IO复用+多线程IO复用(链接线程池)")]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图-5"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://img.kancloud.cn/16/2b/162b19e0bfe51092569c58c06afe8cfb_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析-5"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("① Server在启动监听之前，开辟固定数量(N)的线程，用"),v("code",[_._v("Thead Pool")]),_._v("线程池管理")]),_._v(" "),v("p",[_._v("② 主线程"),v("code",[_._v("main thread")]),_._v("创建"),v("code",[_._v("listenFd")]),_._v("之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有"),v("code",[_._v("Client1")]),_._v("客户端"),v("code",[_._v("Connect")]),_._v("请求，I/O复用机制检测到"),v("code",[_._v("ListenFd")]),_._v("触发读事件，则进行"),v("code",[_._v("Accept")]),_._v("建立连接，并将新生成的"),v("code",[_._v("connFd1")]),_._v("分发给"),v("code",[_._v("Thread Pool")]),_._v("中的某个线程进行监听。")]),_._v(" "),v("p",[_._v("③ "),v("code",[_._v("Thread Pool")]),_._v("中的每个"),v("code",[_._v("thread")]),_._v("都启动"),v("code",[_._v("多路I/O复用机制(select、epoll)")]),_._v(",用来监听"),v("code",[_._v("main thread")]),_._v("建立成功并且分发下来的socket套接字。")]),_._v(" "),v("p",[_._v("④ 如图， "),v("code",[_._v("thread")]),_._v("监听"),v("code",[_._v("ConnFd1、ConnFd2")]),_._v(", "),v("code",[_._v("thread2")]),_._v("监听"),v("code",[_._v("ConnFd3")]),_._v(","),v("code",[_._v("thread3")]),_._v("监听"),v("code",[_._v("ConnFd4")]),_._v(". 当对应的"),v("code",[_._v("ConnFd")]),_._v("有读写事件，对应的线程处理该套接字的读写及业务。")]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点-5"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("将"),v("code",[_._v("main thread")]),_._v("的单流程读写，分散到多线程完成，这样增加了同一时刻的读写并行通道，并行通道数量"),v("code",[_._v("N")]),_._v("， "),v("code",[_._v("N")]),_._v("为线程池"),v("code",[_._v("Thread")]),_._v("数量。")]),_._v(" "),v("li",[_._v("server同时监听的"),v("code",[_._v("ConnFd套接字")]),_._v("数量几乎成倍增大，之前的全部监控数量取决于"),v("code",[_._v("main thread")]),_._v("的"),v("code",[_._v("多路I/O复用机制")]),_._v("的最大限制***(select 默认为1024， epoll默认与内存大小相关，约3~6w不等)***，所以理论单点Server最高响应并发数量为"),v("code",[_._v("N*(3~6W)")]),_._v("("),v("code",[_._v("N")]),_._v("为线程池"),v("code",[_._v("Thread")]),_._v("数量，建议与CPU核心成比例1:1)。")]),_._v(" "),v("li",[_._v("如果良好的线程池数量和CPU核心数适配，那么可以尝试CPU核心与Thread进行绑定，从而降低CPU的切换频率，提升每个"),v("code",[_._v("Thread")]),_._v("处理合理业务的效率，降低CPU切换成本开销。")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("虽然监听的并发数量提升，但是最高读写并行通道依然为"),v("code",[_._v("N")]),_._v("，而且多个身处同一个Thread的客户端，会出现读写延迟现象，实际上每个"),v("code",[_._v("Thread")]),_._v("的模型特征与"),v("code",[_._v("模型三：单线程多路IO复用")]),_._v("一致。")])]),_._v(" "),v("h2",{attrs:{id:"模型五、单进程多路i-o复用-多进程多路i-o复用-进程池"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型五、单进程多路i-o复用-多进程多路i-o复用-进程池"}},[_._v("#")]),_._v(" 模型五、单进程多路I/O复用+多进程多路I/O复用(进程池)")]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图-6"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/9c0554e28f77056946d3696f73ab2915_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析-6"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("与"),v("code",[_._v("五、单线程IO复用+多线程IO复用(链接线程池)")]),_._v("无大差异。")]),_._v(" "),v("p",[_._v("不同处")]),_._v(" "),v("ul",[v("li",[_._v("进程和线程的内存布局不同导致，"),v("code",[_._v("main process")]),_._v("(主进程)不再进行"),v("code",[_._v("Accept")]),_._v("操作，而是将"),v("code",[_._v("Accept")]),_._v("过程分散到各个"),v("code",[_._v("子进程(process)")]),_._v("中.")]),_._v(" "),v("li",[_._v("进程的特性，资源独立，所以"),v("code",[_._v("main process")]),_._v("如果Accept成功的fd，其他进程无法共享资源，所以需要各子进程自行Accept创建链接")]),_._v(" "),v("li",[v("code",[_._v("main process")]),_._v("只是监听"),v("code",[_._v("ListenFd")]),_._v("状态，一旦触发读事件(有新连接请求). 通过一些IPC(进程间通信：如信号、共享内存、管道)等, 让各自子进程"),v("code",[_._v("Process")]),_._v("竞争"),v("code",[_._v("Accept")]),_._v("完成链接建立，并各自监听。")])]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点-6"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[_._v("与"),v("code",[_._v("五、单线程IO复用+多线程IO复用(链接线程池)")]),_._v("无大差异。")]),_._v(" "),v("p",[_._v("不同处:")]),_._v(" "),v("p",[_._v("多进程内存资源空间占用稍微大一些")]),_._v(" "),v("p",[_._v("多进程模型安全稳定型较强，这也是因为各自进程互不干扰的特点导致。")]),_._v(" "),v("h2",{attrs:{id:"模型六、单线程多路i-o复用-多线程多路i-o复用-多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模型六、单线程多路i-o复用-多线程多路i-o复用-多线程"}},[_._v("#")]),_._v(" 模型六、"),v("strong",[_._v("单线程多路I/O复用+多线程多路I/O复用+多线程")])]),_._v(" "),v("h4",{attrs:{id:"_1-模型结构图-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-模型结构图-7"}},[_._v("#")]),_._v(" (1) 模型结构图")]),_._v(" "),v("img",{staticStyle:{zoom:"33%"},attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/b07bc6b3ca5cba69e780509d405a228f_1920x1080.jpeg",alt:"img"}}),_._v(" "),v("h4",{attrs:{id:"_2-模型分析-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-模型分析-7"}},[_._v("#")]),_._v(" (2) 模型分析")]),_._v(" "),v("p",[_._v("① Server在启动监听之前，开辟固定数量(N)的线程，用"),v("code",[_._v("Thead Pool")]),_._v("线程池管理")]),_._v(" "),v("p",[_._v("② 主线程"),v("code",[_._v("main thread")]),_._v("创建"),v("code",[_._v("listenFd")]),_._v("之后，采用多路I/O复用机制(如:select、epoll)进行IO状态阻塞监控。有"),v("code",[_._v("Client1")]),_._v("客户端"),v("code",[_._v("Connect")]),_._v("请求，I/O复用机制检测到"),v("code",[_._v("ListenFd")]),_._v("触发读事件，则进行"),v("code",[_._v("Accept")]),_._v("建立连接，并将新生成的"),v("code",[_._v("connFd1")]),_._v("分发给"),v("code",[_._v("Thread Pool")]),_._v("中的某个线程进行监听。")]),_._v(" "),v("p",[_._v("③ "),v("code",[_._v("Thread Pool")]),_._v("中的每个"),v("code",[_._v("thread")]),_._v("都启动"),v("code",[_._v("多路I/O复用机制(select、epoll)")]),_._v(",用来监听"),v("code",[_._v("main thread")]),_._v("建立成功并且分发下来的socket套接字。一旦其中某个被监听的客户端套接字触发"),v("code",[_._v("I/O读写事件")]),_._v(",那么，会立刻开辟一个新线程来处理"),v("code",[_._v("I/O读写")]),_._v("业务。")]),_._v(" "),v("p",[_._v("④ 但某个读写线程完成当前读写业务，如果当前套接字没有被关闭，那么将当前客户端套接字"),v("code",[_._v("如:ConnFd3")]),_._v("重新加回线程池的监控线程中，同时自身线程自我销毁。")]),_._v(" "),v("h4",{attrs:{id:"_3-优缺点-7"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优缺点-7"}},[_._v("#")]),_._v(" (3) 优缺点")]),_._v(" "),v("p",[v("strong",[_._v("优点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("在"),v("code",[_._v("模型五、单线程IO复用+多线程IO复用(链接线程池)")]),_._v("基础上，除了能够保证同时响应的"),v("code",[_._v("最高并发数")]),_._v("，又能解决"),v("code",[_._v("读写并行通道")]),_._v("局限的问题。")]),_._v(" "),v("li",[_._v("同一时刻的读写并行通道，达到"),v("code",[_._v("最大化极限")]),_._v("，一个客户端可以对应一个单独执行流程处理读写业务，读写并行通道与客户端数量"),v("code",[_._v("1:1")]),_._v("关系。")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("该模型过于理想化，因为要求CPU核心数量足够大。")]),_._v(" "),v("li",[_._v("如果硬件CPU数量可数(目前的硬件情况)，那么该模型将造成大量的CPU切换成本浪费。因为为了保证读写并行通道与客户端"),v("code",[_._v("1:1")]),_._v("的关系，那么Server需要开辟的"),v("code",[_._v("Thread")]),_._v("数量就与客户端一致，那么线程池中做"),v("code",[_._v("多路I/O复用")]),_._v("的监听线程池绑定CPU数量将变得毫无意义。")]),_._v(" "),v("li",[_._v("如果每个临时的读写"),v("code",[_._v("Thread")]),_._v("都能够绑定一个单独的CPU，那么此模型将是最优模型。但是目前CPU的数量无法与客户端的数量达到一个量级，目前甚至差的不是几个量级的事。")])]),_._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("综上，我们整理了7中Server的服务器处理结构模型，每个模型都有各自的特点和优势，那么对于多少应付高并发和高CPU利用率的模型，目前多数采用的是模型五(或模型五进程版，如Nginx就是类似模型五进程版的改版)。")])]),_._v(" "),v("li",[v("p",[_._v("至于并发模型并非设计的约复杂越好，也不是线程开辟的越多越好，我们要考虑硬件的利用与和切换成本的开销。模型六设计就极为复杂，线程较多，但以当今的硬件能力无法支撑，反倒导致该模型性能极差。所以对于不同的业务场景也要选择适合的模型构建，并不是一定固定就要使用某个来应用。")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);