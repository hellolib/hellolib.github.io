(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{537:function(t,s,a){"use strict";a.r(s);var n=a(3),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"redis-常见数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-常见数据类型"}},[t._v("#")]),t._v(" Redis 常见数据类型")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("3.0版本之前数据结构")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("数据类型")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("底层数据结构")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("String(字符串)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("SDS 动态字符串")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("List(列表)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("压缩列表 + 双端链表")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Set(集合-无序)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("hash表")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("ZSet(集合-有序)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("压缩列表 + 跳跃表")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Hash(哈希类型)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("hash表 + 压缩列表")])])])])]),t._v(" "),s("li",[s("p",[t._v("3.0版本之后数据结构")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("数据类型")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("底层数据结构")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("String(字符串)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("SDS 动态字符串")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("List(列表)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("quicklist")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Set(集合-无序)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("hash表")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("ZSet(集合-有序)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("listpack + 跳跃表")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("Hash(哈希类型)")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("hash表 +listpack")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704153014.png",alt:"img"}})])])]),t._v(" "),s("h2",{attrs:{id:"redis-键值对数据库实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-键值对数据库实现原理"}},[t._v("#")]),t._v(" Redis 键值对数据库实现原理")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Redis 的键值对中的 key 就是字符串对象，而 "),s("strong",[t._v("value 可以是字符串对象，也可以是集合数据类型的对象")]),t._v("，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。")])]),t._v(" "),s("li",[s("p",[t._v("demo")]),t._v(" "),s("div",{staticClass:"language-redis line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('> SET name "xiaolincoding"\nOK\n> HSET person name "xiaolincoding" age 18\n0\n> RPUSH stu "xiaolin" "xiaomei"\n(integer) 4\n\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("ul",[s("li",[t._v("第一条命令：name 是一个"),s("strong",[t._v("字符串键")]),t._v("，因为键的"),s("strong",[t._v("值是一个字符串对象")]),t._v("；")]),t._v(" "),s("li",[t._v("第二条命令：person 是一个"),s("strong",[t._v("哈希表键")]),t._v("，因为键的"),s("strong",[t._v("值是一个包含两个键值对的哈希表对象")]),t._v("；")]),t._v(" "),s("li",[t._v("第三条命令：stu 是一个"),s("strong",[t._v("列表键")]),t._v("，因为键的"),s("strong",[t._v("值是一个包含两个元素的列表对象")]),t._v("；")])])]),t._v(" "),s("li",[s("p",[t._v("Redis 是使用了一个「哈希表」保存所有键值对(这个hash表的负载因子是1)，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。")]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("负载因子 = 键数量/bucket数量")]),t._v(" "),s("li",[t._v("哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织：\n"),s("ul",[s("li",[s("p",[t._v("哈希因子过小，说明空间利用率低")])]),t._v(" "),s("li",[s("p",[t._v("哈希因子过大，说明冲突严重，存取效率低")])])])]),t._v(" "),s("li",[t._v("每个哈希表的实现对负载因子容忍程度不同，Redis实现中负载因子大于1时就会触发rehash，"),s("strong",[t._v("而Go则在在负载因子达到6.5时才会触发rehash")]),t._v("，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。")])])])]),t._v(" "),s("li",[s("p",[t._v("哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704151940.png",alt:"img"}})])])]),t._v(" "),s("h2",{attrs:{id:"redis-底层数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-底层数据结构"}},[t._v("#")]),t._v(" Redis 底层数据结构")]),t._v(" "),s("h3",{attrs:{id:"_1-sds-动态字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-sds-动态字符串"}},[t._v("#")]),t._v(" 1. SDS 动态字符串")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("C 语言的字符串的缺陷")]),t._v(" "),s("ul",[s("li",[t._v("C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符")]),t._v(" "),s("li",[t._v("C 语言获取字符串长度的时间复杂度是 O(N), 就是获取字符串长度的时候需要遍历字符串")]),t._v(" "),s("li",[t._v("字符串的结尾是以 “\\0” 字符标识，字符串里面不能包含有 “\\0” 字符，因此不能保存二进制数据；")]),t._v(" "),s("li",[t._v("字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；")])])]),t._v(" "),s("li",[s("p",[t._v("SDS数据结构")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704152406.png",alt:"img"}})]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("len，记录了字符串长度")]),t._v("。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。")]),t._v(" "),s("li",[s("strong",[t._v("alloc，分配给字符数组的空间长度")]),t._v("。这样在修改字符串的时候，可以通过 "),s("code",[t._v("alloc - len")]),t._v(" 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。")]),t._v(" "),s("li",[s("strong",[t._v("flags，用来表示不同类型的 SDS")]),t._v("。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。")]),t._v(" "),s("li",[s("strong",[t._v("buf[]，字符数组，用来保存实际数据")]),t._v("。不仅可以保存字符串，也可以保存二进制数据。")])])])]),t._v(" "),s("h3",{attrs:{id:"_2-链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-链表"}},[t._v("#")]),t._v(" 2. 链表")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("数据结构")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("list")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//链表头节点")]),t._v("\n    listNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//链表尾节点")]),t._v("\n    listNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//节点值复制函数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dup"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//节点值释放函数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("free"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//节点值比较函数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("match"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//链表节点数量")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("优缺点")])]),t._v(" "),s("ul",[s("li",[t._v("优点\n"),s("ol",[s("li",[t._v("listNode 链表节点的结构里带有 prev 和 next 指针，"),s("strong",[t._v("获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表")]),t._v("；")]),t._v(" "),s("li",[t._v("list 结构因为提供了表头指针 head 和表尾节点 tail，所以"),s("strong",[t._v("获取链表的表头节点和表尾节点的时间复杂度只需O(1)")]),t._v("；")]),t._v(" "),s("li",[t._v("list 结构因为提供了链表节点数量 len，所以"),s("strong",[t._v("获取链表中的节点数量的时间复杂度只需O(1)")]),t._v("；")]),t._v(" "),s("li",[t._v("listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此"),s("strong",[t._v("链表节点可以保存各种不同类型的值")]),t._v("；")])])]),t._v(" "),s("li",[t._v("缺点\n"),s("ol",[s("li",[t._v("表每个节点之间的内存都是不连续的，意味着"),s("strong",[t._v("无法很好利用 CPU 缓存")]),t._v("。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。")]),t._v(" "),s("li",[t._v("还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，"),s("strong",[t._v("内存开销较大")]),t._v("。")])])])])])]),t._v(" "),s("h3",{attrs:{id:"_3-压缩列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-压缩列表"}},[t._v("#")]),t._v(" 3. 压缩列表")]),t._v(" "),s("blockquote",[s("p",[t._v("压缩列表是 Redis 为了节约内存而开发的，它是"),s("strong",[t._v("由连续内存块组成的顺序型数据结构")]),t._v("，有点类似于数组。")])]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("数据结构")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704154010.png",alt:"img"}})]),t._v(" "),s("ul",[s("li",[s("em",[s("strong",[t._v("zlbytes")])]),t._v("，记录整个压缩列表占用对内存字节数；")]),t._v(" "),s("li",[s("em",[s("strong",[t._v("zltail")])]),t._v("，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；")]),t._v(" "),s("li",[s("em",[s("strong",[t._v("zllen")])]),t._v("，记录压缩列表包含的节点数量；")]),t._v(" "),s("li",[s("em",[s("strong",[t._v("zlend")])]),t._v("，标记压缩列表的结束点，固定值 0xFF（十进制255）")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("优缺点")])]),t._v(" "),s("ul",[s("li",[t._v("优点: 压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。")]),t._v(" "),s("li",[t._v("缺点:\n"),s("ol",[s("li",[t._v("不能保存过多的元素，否则查询效率就会降低；")]),t._v(" "),s("li",[t._v("新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。")]),t._v(" "),s("li",[s("strong",[t._v("虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题")]),t._v("。"),s("strong",[t._v("压缩列表只会用于保存的节点数量不多的场景")]),t._v("，只要节点数量足够小，即使发生连锁更新，也是能接受的。")])])])])])]),t._v(" "),s("h3",{attrs:{id:"_4-哈希表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-哈希表"}},[t._v("#")]),t._v(" 4. 哈希表")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("数据结构")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("dictht")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//哈希表数组")]),t._v("\n    dictEntry "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("table"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//哈希表大小")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" size"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//哈希表大小掩码，用于计算索引值")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" sizemask"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//该哈希表已有的节点数量")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" used"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" dictht"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("ul",[s("li",[s("p",[t._v("可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704154304.png",alt:"img"}})])])])]),t._v(" "),s("li",[s("p",[t._v("rehash"),s("strong",[t._v("流程")])]),t._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[t._v("当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。")])]),t._v(" "),s("li",[s("strong",[t._v("当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704154450.png",alt:"img"}})])])]),t._v(" "),s("h3",{attrs:{id:"_5-整数集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-整数集合"}},[t._v("#")]),t._v(" 5. 整数集合")]),t._v(" "),s("blockquote",[s("p",[t._v("整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。")])]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("数据结构")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("intset")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//编码方式")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" encoding"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//集合包含的元素数量")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("uint32_t")]),t._v(" length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//保存元素的数组")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("int8_t")]),t._v(" contents"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" intset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br")])])])]),t._v(" "),s("h3",{attrs:{id:"_6-跳表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-跳表"}},[t._v("#")]),t._v(" 6. 跳表 !!!")]),t._v(" "),s("blockquote",[s("ul",[s("li",[s("p",[t._v("Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。")])]),t._v(" "),s("li",[s("p",[t._v("Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("zset")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    dict "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("dict"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    zskiplist "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("zsl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" zset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])])]),t._v(" "),s("li",[s("p",[t._v("Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。")])])])]),t._v(" "),s("h4",{attrs:{id:"_6-1-数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-数据结构"}},[t._v("#")]),t._v(" 6.1  数据结构")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("跳跃表数据结构")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("zskiplist")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("zskiplistNode")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" level"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" zskiplist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ul",[s("li",[t._v("跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；")]),t._v(" "),s("li",[t._v("跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；")]),t._v(" "),s("li",[t._v("跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；")])])]),t._v(" "),s("li",[s("p",[t._v("链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。"),s("strong",[t._v("跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表")]),t._v("，这样的好处是能快读定位数据。")])]),t._v(" "),s("li",[s("p",[t._v("一个层级为 3 的跳表")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704155310.png",alt:"img"}})])]),t._v(" "),s("li",[s("p",[t._v("图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：")]),t._v(" "),s("ul",[s("li",[t._v("L0 层级共有 5 个节点，分别是节点1、2、3、4、5；")]),t._v(" "),s("li",[t._v("L1 层级共有 3 个节点，分别是节点 2、3、5；")]),t._v(" "),s("li",[t._v("L2 层级只有 1 个节点，也就是节点 3 。")])])]),t._v(" "),s("li",[s("p",[t._v("如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。")])]),t._v(" "),s("li",[s("p",[t._v("可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。")])])]),t._v(" "),s("h4",{attrs:{id:"_6-2-跳跃表的查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-跳跃表的查询"}},[t._v("#")]),t._v(" 6.2 跳跃表的查询")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：")]),t._v(" "),s("ul",[s("li",[t._v("如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。")]),t._v(" "),s("li",[t._v("如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。")])])]),t._v(" "),s("li",[s("p",[t._v("如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。举个例子，下图有个 3 层级的跳表。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704160119.png",alt:"img"}})])]),t._v(" "),s("li",[s("p",[t._v("如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；")])]),t._v(" "),s("li",[s("p",[t._v("但是该层上的下一个节点是空节点，于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];")])]),t._v(" "),s("li",[s("p",[t._v("「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；")])]),t._v(" "),s("li",[s("p",[t._v("「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。")])])])])]),t._v(" "),s("h3",{attrs:{id:"_7-quicklist"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-quicklist"}},[t._v("#")]),t._v(" 7. quicklist")]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。")]),t._v(" "),s("li",[t._v("压缩列表有问题, quicklist 解决办法，"),s("strong",[t._v("通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。")])])])]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("数据结构")])]),t._v(" "),s("ul",[s("li",[t._v("quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。")])]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("quicklist")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//quicklist的链表头")]),t._v("\n    quicklistNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("head"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//quicklist的链表头")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//quicklist的链表头")]),t._v("\n    quicklistNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("tail"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//所有压缩列表中的总元素个数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//quicklistNodes的个数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       \n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" quicklist"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220704160559.png",alt:"img"}})])])]),t._v(" "),s("h3",{attrs:{id:"_8-listpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-listpack"}},[t._v("#")]),t._v(" 8. listpack")]),t._v(" "),s("ul",[s("li",[t._v("quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。")]),t._v(" "),s("li",[t._v("因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。")]),t._v(" "),s("li",[t._v("于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);