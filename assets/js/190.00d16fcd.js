(window.webpackJsonp=window.webpackJsonp||[]).push([[190],{510:function(s,t,e){"use strict";e.r(t);var a=e(3),n=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"普通redis分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通redis分布式锁"}},[s._v("#")]),s._v(" 普通redis分布式锁")]),s._v(" "),t("blockquote",[t("p",[s._v("SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：")])]),s._v(" "),t("ul",[t("li",[t("p",[s._v("如果 key 不存在，则显示插入成功，可以用来表示加锁成功；")])]),s._v(" "),t("li",[t("p",[s._v("如果 key 存在，则会显示插入失败，可以用来表示加锁失败。")])]),s._v(" "),t("li",[t("p",[s._v("一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：")]),s._v(" "),t("div",{staticClass:"language-redis line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("SET lock_key unique_value NX PX 10000\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("ul",[t("li",[t("code",[s._v("lock_key")]),s._v("就是 key 键；")]),s._v(" "),t("li",[t("code",[s._v("unique_value")]),s._v("是客户端生成的唯一的标识；")]),s._v(" "),t("li",[t("code",[s._v("NX")]),s._v(" 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；")]),s._v(" "),t("li",[t("code",[s._v("PX")]),s._v(" 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。")])])]),s._v(" "),t("li",[t("p",[s._v("而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。")])]),s._v(" "),t("li",[t("p",[s._v("可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。")]),s._v(" "),t("div",{staticClass:"language-lua line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-lua"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("//")]),s._v(" 释放锁时，先比较 unique_value 是否相等，避免锁的误释放\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" redis"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("call")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"get"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("KEYS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" ARGV"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("then")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" redis"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("call")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"del"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("KEYS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("end")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("ul",[t("li",[s._v("这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。")])])])]),s._v(" "),t("h2",{attrs:{id:"redlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redlock"}},[s._v("#")]),s._v(" RedLock")]),s._v(" "),t("blockquote",[t("p",[s._v("redlock 也是分布式缓存的一种官方解决方案")])]),s._v(" "),t("h3",{attrs:{id:"_1-为什么需要redlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么需要redlock"}},[s._v("#")]),s._v(" 1. 为什么需要RedLock")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("因为普通的分布式锁算法在加锁时它的KEY只会存在于某一个Redis Master实例以及它的slave上（假如有slave的话， 即使cluster集群模式，也是一样的。因为一个KEY只会属于一个slot，一个slot只会属于一个Redis节点），而Redis又不是基于CP模型的。那么就会有很大概率存在锁丢失的情况。以如下场景为例：")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("线程T1在M1中加锁成功。")])]),s._v(" "),t("li",[t("p",[s._v("M1出现故障，但是由于主从同步延迟问题，加锁的KEY并没有同步到S1上。")])]),s._v(" "),t("li",[t("p",[s._v("S1升级为Master节点。")])]),s._v(" "),t("li",[t("p",[s._v("另一个线程T2在S1上也加锁成功，从而导致线程T1和T2都获取到了分布式锁。")])])])]),s._v(" "),t("li",[t("p",[s._v("RedLock方法就是根除普通基于Redis分布式锁而生的（无论是主从模式、sentinel模式还是cluster模式）！官方把RedLock方法当作"),t("strong",[s._v("使用Redis实现分布式锁的规范算法")]),s._v("，并认为这种实现比普通的单实例或者基于Redis Cluster的实现更安全。")])])]),s._v(" "),t("h3",{attrs:{id:"_2-redlock-实现流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-redlock-实现流程"}},[s._v("#")]),s._v(" 2. RedLock 实现流程")]),s._v(" "),t("blockquote",[t("p",[s._v("在Redis的分布式环境中，我们假设有N个Redis Master。这些节点"),t("strong",[s._v("完全互相独立，不存在主从复制或者其他集群协调机制")]),s._v("（这句话非常重要，如果没有理解这句话，也就无法理解RedLock。并且由这句话我们可以得出，RedLock依赖的环境不能是一个由N主N从组成的Cluster集群模式，因为Cluster模式下的各个Master并不完全独立，而是存在Gossip协调机制的）。")])]),s._v(" "),t("ul",[t("li",[t("p",[s._v("假设有3个完全相互独立的Redis Master单机节点，所以我们需要在3台机器上面运行这些实例")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220724124807.png",alt:"image-20220724124807396"}})])])]),s._v(" "),t("ol",[t("li",[s._v("获取当前Unix时间，以毫秒为单位。")]),s._v(" "),t("li",[s._v("依次尝试"),t("strong",[s._v("从N个Master实例使用相同的key和随机值获取锁")]),s._v("（假设这个key是LOCK_KEY）。当向Redis设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。")]),s._v(" "),t("li",[s._v("客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当"),t("strong",[s._v("从大多数的Redis节点都取到锁")]),s._v("，并且使用的时间小于锁失效时间时，锁才算获取成功。")]),s._v(" "),t("li",[s._v("如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。")]),s._v(" "),t("li",[s._v("如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在"),t("strong",[s._v("所有的Redis实例上进行解锁")]),s._v("（即便某些Redis实例根本就没有加锁成功）。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);