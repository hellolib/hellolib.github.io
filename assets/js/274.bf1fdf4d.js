(window.webpackJsonp=window.webpackJsonp||[]).push([[274],{594:function(_,t,v){"use strict";v.r(t);var i=v(3),l=Object(i.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("blockquote",[t("p",[t("strong",[_._v("设计模式")]),_._v("是软件设计中常见问题的典型解决方案，是无数先驱和前辈总结的编码设计经验。")])]),_._v(" "),t("h2",{attrs:{id:"设计模式特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式特征"}},[_._v("#")]),_._v(" 设计模式特征")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("设计模式与方法或库的使用方式不同，你很难直接在自己的程序中套用某个设计模式。模式并不是一段特定的代码，而是解决特定问题的一般性概念。你可以根据模式来实现符合自己程序实际所需的解决方案。")])]),_._v(" "),t("li",[t("p",[_._v("设计模式和算法的区别")]),_._v(" "),t("ul",[t("li",[_._v("算法更像是菜谱：提供达成目标的明确步骤。")]),_._v(" "),t("li",[_._v("模式更像是蓝图：你可以看到最终的结果和模式的功能，但需要自己确定实现步骤。")])])]),_._v(" "),t("li",[t("p",[_._v("设计模式分类：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("创建型模式")]),_._v("：提供创建对象的机制，增加已有代码的灵活性和可复用性。")]),_._v(" "),t("li",[t("strong",[_._v("结构型模式")]),_._v("：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。")]),_._v(" "),t("li",[t("strong",[_._v("行为模式")]),_._v("：负责对象间的高效沟通和职责委派。")])])]),_._v(" "),t("li",[t("p",[_._v("设计模式的作用：")]),_._v(" "),t("ul",[t("li",[_._v("设计模式是针对软件设计中常见问题的工具箱，其中的工具就是各种"),t("strong",[_._v("经过实践验证的解决方案")]),_._v("。")]),_._v(" "),t("li",[_._v("设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。")])])])]),_._v(" "),t("h2",{attrs:{id:"软件设计原则-solid原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件设计原则-solid原则"}},[_._v("#")]),_._v(" 软件设计原则- SOLID原则")]),_._v(" "),t("ul",[t("li",[t("em",[_._v("SOLID")]),_._v(" 是让软件设计更易于理解、更加灵活和更易于维护的五个原则的简称。")])]),_._v(" "),t("h3",{attrs:{id:"_1-s-单一职责原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-s-单一职责原则"}},[_._v("#")]),_._v(" 1. S 单一职责原则")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("Single Responsibility Principle")]),_._v("  一个方法只完成一件事")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("尽量让每个类只负责软件中的一个功能，并将该功能完全封装（你也可称之为隐藏）在该类中。")])]),_._v(" "),t("li",[t("p",[_._v("这条原则的主要目的是减少复杂度。你不需要费尽心机地去构思如何仅用 200 行代码来实现复杂设计，实际上完全可以使用十几个清晰的方法。")])]),_._v(" "),t("li",[t("p",[_._v("demo")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("修改前：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221114172257.png",alt:"image-20221114172257478"}})])]),_._v(" "),t("li",[t("p",[_._v("修改后：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221114172314.png",alt:"image-20221114172314866"}})])])])])]),_._v(" "),t("h3",{attrs:{id:"_2-o-开闭原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-o-开闭原则"}},[_._v("#")]),_._v(" 2. O 开闭原则")]),_._v(" "),t("blockquote",[t("p",[_._v("pen/Closesd Principle 对扩展开发，对修改关闭（常见做法：多态、基于接口实现、依赖注入）。")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("本原则的主要理念是在实现新功能时能保持已有代码不变。")])]),_._v(" "),t("li",[t("p",[_._v("如果你可以对一个类进行扩展， 可以创建它的子类并对其做 任何事情（如新增方法或成员变量、 重写基类行为等）， 那 么它就是开放的。 有些编程语言允许你通过特殊关键字（例 如 final ） 来限制对于类的进一步扩展， 这样类就不再是 “开放”的了。 如果某个类已做好了充分的准备并可供其他 类使用的话（即其接口已明确定义且以后不会修改）， 那么该类就是封闭（你可以称之为完整）的。")])]),_._v(" "),t("li",[t("p",[_._v("demo")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("你的电子商务程序中包含一个计算运输费用的 订单 Order 类， 该类中所有运输方法都以硬编码的方式实现。 如果你需 要添加一个新的运输方式， 那就必须承担对 订单 类造成破 坏的可能风险来对其进行修改。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115150930.png",alt:"image-20221115150929996"}})])]),_._v(" "),t("li",[t("p",[_._v("可以通过应用策略模式来解决这个问题。 首先将运输方法 抽取到拥有同样接口的不同类中。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115151023.png",alt:"image-20221115151023036"}})])])])])]),_._v(" "),t("h3",{attrs:{id:"_3-l-里氏替换原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-l-里氏替换原则"}},[_._v("#")]),_._v(" 3. L 里氏替换原则")]),_._v(" "),t("blockquote",[t("p",[_._v("Liskov Substitution Principle  子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。")])]),_._v(" "),t("ul",[t("li",[_._v("替换原则是用于预测子类是否与代码兼容， 以及是否能与其 超类对象协作的一组检查。 这一概念在开发程序库和框架时 非常重要， 因为其中的类将会在他人的代码中使用——你是 无法直接访问和修改这些代码的。")]),_._v(" "),t("li",[_._v("替换原则要求：\n"),t("ol",[t("li",[_._v("子类方法的参数类型必须与其超类的参数类型相匹配或更加 抽象。")]),_._v(" "),t("li",[_._v("子类方法的返回值类型必须与超类方法的返回值类型或是其 子类别相匹配。")]),_._v(" "),t("li",[_._v("子类中的方法不应抛出基础方法预期之外的异常类型。")]),_._v(" "),t("li",[_._v("子类不应该加强其前置条件。")]),_._v(" "),t("li",[_._v("子类不能削弱其后置条件。")]),_._v(" "),t("li",[_._v("子类不能修改超类中私有成员变量的值。")])])])]),_._v(" "),t("h3",{attrs:{id:"_4-i-接口隔离原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-i-接口隔离原则"}},[_._v("#")]),_._v(" 4. I 接口隔离原则")]),_._v(" "),t("blockquote",[t("p",[_._v("Interface Segregation Principle 客户端不应被强迫依赖于其不使用的方法。")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("根据接口隔离原则， 你必须将“臃肿”的方法拆分为多个颗 粒度更小的具体方法。 客户端必须仅实现其实际需要的方法。 否则， 对于“臃肿”接口的修改可能会导致程序出错， 即使 客户端根本没有使用修改后的方法。")])]),_._v(" "),t("li",[t("p",[_._v("继承只允许类拥有一个超类， 但是它并不限制类可同时实现 的接口的数量。 因此， 你不需要将大量无关的类塞进单个接 口。 你可将其拆分为更精细的接口， 如有需要可在单个类中 实现所有接口， 某些类也可只实现其中的一个接口。")])]),_._v(" "),t("li",[t("p",[_._v("demo：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115151731.png",alt:"image-20221115151731175"}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115151751.png",alt:"image-20221115151751487"}})])])]),_._v(" "),t("h3",{attrs:{id:"_5-d-依赖倒置原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-d-依赖倒置原则"}},[_._v("#")]),_._v(" 5. D 依赖倒置原则")]),_._v(" "),t("blockquote",[t("p",[_._v("Dependency Inversion Principle 高层次的类不应该依赖于低层次的类。 两者都应该依 赖于抽象接口。 抽象接口不应依赖于具体实现。 具体 实现应该依赖于抽象接口。依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。")])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("低层次的类实现基础操作（例如磁盘操作、传输网络数据和连接数据库等）。")])]),_._v(" "),t("li",[t("p",[_._v("高层次类包含复杂业务逻辑以指导低层次类执行特定操作。")])]),_._v(" "),t("li",[t("p",[_._v("demo")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115152548.png",alt:""}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20221115152602.png",alt:"image-20221115152602170"}})])])]),_._v(" "),t("h2",{attrs:{id:"设计模式分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式分类"}},[_._v("#")]),_._v(" 设计模式分类")]),_._v(" "),t("h3",{attrs:{id:"_1-创建型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建型模式"}},[_._v("#")]),_._v(" 1. 创建型模式")]),_._v(" "),t("ol",[t("li",[_._v("工厂方法")]),_._v(" "),t("li",[_._v("抽象工厂")]),_._v(" "),t("li",[_._v("生成器")]),_._v(" "),t("li",[_._v("原型")]),_._v(" "),t("li",[_._v("单例")])]),_._v(" "),t("h3",{attrs:{id:"_2-结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-结构型模式"}},[_._v("#")]),_._v(" 2. 结构型模式")]),_._v(" "),t("ol",[t("li",[_._v("适配器")]),_._v(" "),t("li",[_._v("桥接")]),_._v(" "),t("li",[_._v("组合")]),_._v(" "),t("li",[_._v("装饰")]),_._v(" "),t("li",[_._v("外观")]),_._v(" "),t("li",[_._v("亨元")]),_._v(" "),t("li",[_._v("代理")])]),_._v(" "),t("h3",{attrs:{id:"_3-行为型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-行为型模式"}},[_._v("#")]),_._v(" 3. 行为型模式")]),_._v(" "),t("ol",[t("li",[_._v("责任链")]),_._v(" "),t("li",[_._v("命令模式")]),_._v(" "),t("li",[_._v("迭代器")]),_._v(" "),t("li",[_._v("中介者")]),_._v(" "),t("li",[_._v("备忘录")]),_._v(" "),t("li",[_._v("观察者")]),_._v(" "),t("li",[_._v("状态")]),_._v(" "),t("li",[_._v("策略")]),_._v(" "),t("li",[_._v("模板方法")]),_._v(" "),t("li",[_._v("访问者")])])])}),[],!1,null,null,null);t.default=l.exports}}]);