(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{516:function(v,_,e){"use strict";e.r(_);var l=e(3),t=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"定期删除和惰性删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定期删除和惰性删除"}},[v._v("#")]),v._v(" 定期删除和惰性删除")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("我们Redis设置了过期时间，其实内部是 定期删除 + 惰性删除两个再起作用的。")])]),v._v(" "),_("li",[_("p",[v._v("所谓定期删除，指的是redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。假设redis里放了10万个key，都设置了过期时间，你每隔几百毫秒，就检查10万个key，那redis基本上就死了，cpu负载会很高的，消耗在你的检查过期key上了。注意，这里可不是每隔100ms就遍历所有的设置过期时间的key，那样就是一场性能上的灾难。实际上redis是每隔100ms随机抽取一些key来检查和删除的。")])]),v._v(" "),_("li",[_("p",[v._v("但是问题是，定期删除可能会导致很多过期key到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个key的时候，redis会检查一下 ，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。")])]),v._v(" "),_("li",[_("p",[v._v("并不是key到时间就被删除掉，而是你查询这个key的时候，redis再懒惰的检查一下")])]),v._v(" "),_("li",[_("p",[v._v("通过上述两种手段结合起来，保证过期的key一定会被干掉。")])]),v._v(" "),_("li",[_("p",[v._v("很简单，就是说，你的过期key，靠定期删除没有被删除掉，还停留在内存里，占用着你的内存呢，除非你的系统去查一下那个key，才会被redis给删除掉。")])]),v._v(" "),_("li",[_("p",[v._v("但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？")])])]),v._v(" "),_("blockquote",[_("p",[v._v("答案是：走内存淘汰机制。")])]),v._v(" "),_("h2",{attrs:{id:"redis数据淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis数据淘汰策略"}},[v._v("#")]),v._v(" redis数据淘汰策略")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("noeviction")]),v._v("(不淘汰)：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了")]),v._v(" "),_("li",[_("strong",[v._v("allkeys-lru")]),v._v("：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）")]),v._v(" "),_("li",[_("strong",[v._v("allkeys-random")]),v._v("：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊")]),v._v(" "),_("li",[_("strong",[v._v("volatile-lru")]),v._v("：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）")]),v._v(" "),_("li",[_("strong",[v._v("volatile-random")]),v._v("：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key")]),v._v(" "),_("li",[_("strong",[v._v("volatile-ttl")]),v._v("：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除")])]),v._v(" "),_("h2",{attrs:{id:"lru-和-lfu"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lru-和-lfu"}},[v._v("#")]),v._v(" LRU 和 LFU")]),v._v(" "),_("p",[_("em",[v._v("详细参考我的博客: https://bigox.wiki/")])]),v._v(" "),_("blockquote",[_("p",[v._v("LRU和LFU都是内存管理的页面置换算法。")]),v._v(" "),_("p",[v._v("LRU：最近最少使用(最长时间)淘汰算法（Least Recently Used）。LRU是淘汰最长时间没有被使用的页面。")]),v._v(" "),_("p",[v._v("LFU：最不经常使用(最少次)淘汰算法（Least Frequently Used）。LFU是淘汰一段时间内，使用次数最少的页面。")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("例子")]),v._v(" "),_("blockquote",[_("p",[v._v("假设LFU方法的时期T为10分钟，访问如下页面所花的时间正好为10分钟，内存块大小为3。若所需页面顺序依次如下：")]),v._v(" "),_("p",[v._v("2  1  2  1  2  3  4")]),v._v(" "),_("p",[v._v("----------------------------------------\x3e")])]),v._v(" "),_("ul",[_("li",[v._v("当需要使用页面4时，内存块中存储着1、2、3，内存块中没有页面4，就会发生缺页中断，而且此时内存块已满，需要进行页面置换。")]),v._v(" "),_("li",[v._v("若按LRU算法，应替换掉页面1。因为页面1是最长时间没有被使用的了，页面2和3都在它后面被使用过。")]),v._v(" "),_("li",[v._v("若按LFU算法，应换页面3。因为在这段时间内，页面1被访问了2次，页面2被访问了3次，而页面3只被访问了1次，一段时间内被访问的次数最少。")])]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("LRU 关键是看页面最后一次被使用到发生替换的时间长短，时间越长，页面就会被置换；")])]),v._v(" "),_("p",[_("strong",[v._v("LFU关键是看一定时间段内页面被使用的频率（次数），使用频率越低，页面就会被置换。")])])])]),v._v(" "),_("li",[_("p",[v._v("LRU算法适合：较大的文件比如游戏客户端（最近加载的地图文件）;")])]),v._v(" "),_("li",[_("p",[v._v("LFU算法适合：较小的文件和零碎的文件比如系统文件、应用程序文件 ;")])]),v._v(" "),_("li",[_("p",[v._v("LRU消耗CPU资源较少，LFU消耗CPU资源较多。")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);