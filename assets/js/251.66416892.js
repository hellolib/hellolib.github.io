(window.webpackJsonp=window.webpackJsonp||[]).push([[251],{571:function(t,e,l){"use strict";l.r(e);var a=l(3),_=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"docker容器技术与传统虚拟化技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker容器技术与传统虚拟化技术"}},[t._v("#")]),t._v(" Docker容器技术与传统虚拟化技术")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Docker容器技术是一个与传统的虚拟化技术有些本质上的差别，传统的虚拟化技术，是站硬件物理资源的基础上，虚拟出多个OS，然后在OS的基础上构建相对独立的程序运行环境，而Docker则是在OS的基础上进行虚拟，所以，Docker轻量很多，因此其资源占用、性能消耗相比传统虚拟化都有很大的优势。")])]),t._v(" "),e("li",[e("p",[t._v("docker容器很快，启动和停止可以在秒级实现，比传统的虚拟化技术要快很多，docker核心解决的问题是利用容器来实现类似VM的功能，从而节省更多的硬件资源，docker容器除了运行其中的应用之外，基本不消耗额外的系统资源，从而在保证性能的同时，减小系统开销，同时，它还可以达到“一次封装，到处运行”的目的。")])])]),t._v(" "),e("h3",{attrs:{id:"_1-docker和传统虚拟化的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-docker和传统虚拟化的区别"}},[t._v("#")]),t._v(" 1. Docker和传统虚拟化的区别")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("特性")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("Docker容器")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("传统虚拟化技术")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("启动速度")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("秒级")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("分钟级")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("隔离性")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("资源限制")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("完全隔离")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("性能")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("接近原生")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("弱于")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("计算机能力消耗")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("几乎无")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("损耗50%左右")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("系统支持量（单机）")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("上千个")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("几十个")])])])]),t._v(" "),e("ul",[e("li",[t._v("机构上的区别")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/hellolib/pictures/main/Typora/pic-00-gitee/20220705175537",alt:"img"}})]),t._v(" "),e("h2",{attrs:{id:"namespace和cgroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#namespace和cgroup"}},[t._v("#")]),t._v(" NameSpace和Cgroup")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Docker中有三个核心概念，分别是镜像、容器、仓库。而镜像的概念主要就是把运行环境和业务代码进行镜像打包，每个镜像都会存在多个“层”，镜像层都是只读的，不能往里写数据，如果想要写，就需要在其基础之上启动成一个容器， 在容器层，我们是可写的。")])]),t._v(" "),e("li",[e("p",[t._v("在镜像的多个“层”中，有一个busybox的概念，我将它理解为欺骗层。 虚拟化的技术就是来解决"),e("a",{attrs:{href:"https://cloud.tencent.com/product/cdh?from=10680",target:"_blank",rel:"noopener noreferrer"}},[t._v("宿主机"),e("OutboundLink")],1),t._v("与虚拟机之间的耦合问题（简称“解耦”），传统虚拟化是属于完全解耦的，而docker是属于半解耦的。关于“耦合、解耦”的概念可以参考文档："),e("a",{attrs:{href:"https://blog.csdn.net/shenwansangz/article/details/82284957",target:"_blank",rel:"noopener noreferrer"}},[e("strong",[t._v("什么是耦合、解耦？")]),e("OutboundLink")],1)])])]),t._v(" "),e("h3",{attrs:{id:"_1-namespace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-namespace"}},[t._v("#")]),t._v(" 1. NameSpace")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Docker技术是如何解耦的呢？这就引入了NameSpace的概念，其目的是将某个特定的全局系统资源通过抽象的方法使得NameSpace中的进程看起来拥有他们自己的隔离的全局系统资源实例，Docker技术通过Linux内核实现了六种NameSpace，"),e("strong",[t._v("如下：")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("Namespace")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("系统调用参数")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("隔离内容")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("UTS")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("CLONE_NEWUTS")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("主机名与域名")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("IPC")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("CLONE_NEWIPC")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("信息量、消息队列和共享内存")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("PID")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("CLONE_NEWPID")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("进程编号")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("Network")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("CLONE_NEWNET")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("网络设备、网络栈、端口等等")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("Mount")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("CLONE_NEWNS")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("挂载点（文件系统）")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("User")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("CLONE_NEWUSER")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("用户和用户组")])])])])]),t._v(" "),e("li",[e("p",[t._v("当Docker创建一个容器时，它会创建新的以上六种NameSpace的实例，然后把容器中的所有进程放到这些NameSpace之中，使得容器这个父进程只对自己的子进程有感知，而对于宿主机其他进程一无所知，从而产生一种它就是一个独立的系统的“错觉”。")])])]),t._v(" "),e("h3",{attrs:{id:"_2-cgroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-cgroup"}},[t._v("#")]),t._v(" 2. Cgroup")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("Cgroup作用：控制程序对资源的占用。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("Cgroup的具体作用如下：")])]),t._v(" "),e("ol",[e("li",[t._v("限制资源的使用：Cgroup可以对进程组使用的资源总额进行限制；")]),t._v(" "),e("li",[t._v("优先级控制：通过分配CPU时间片数量及磁盘IO带宽大小，实际上就是相当于控制子进程运行的优先级。")]),t._v(" "),e("li",[t._v("资源统计：Cgroup可以统计系统资源使用量，比如CPU使用时间，内存使用量等。可用于按量计费。")]),t._v(" "),e("li",[t._v("进程控制：恢复执行进程；")])])]),t._v(" "),e("li",[e("p",[t._v("使用Cgroup，我们可以更具体地控制对系统资源的分配、优先顺序、拒绝、管理和监控。可更好地根据任务和用户分配硬件资源，提高总体的效率，这样可以在docker容器中的服务受到外部干扰时，可以将其限制在容器之中，而不会影响宿主机或其他容器的运行，提高了安全性。")])])])])}),[],!1,null,null,null);e.default=_.exports}}]);